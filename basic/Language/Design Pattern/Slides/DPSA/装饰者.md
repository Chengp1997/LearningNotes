# 装饰者模式

[参考：Java实现装饰者模式](https://www.cnblogs.com/chenxing818/p/4705919.html)

## 适用情况

* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 
* 处理可以撤消的职责。
* 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的 子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

## 参与者

1. Component（被装饰对象的基类）

定义一个对象接口，可以给这些对象动态地添加职责。

2. ConcreteComponent（具体被装饰对象）

定义一个对象，可以给这个对象添加一些职责。

3. Decorator（装饰者抽象类）

 维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。

4. ConcreteDecorator（具体装饰者） 

具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。



## 类图

![装饰者模式类图](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\1545062684963.png)

## 要点

1、继承属于扩展形式之一，但不见得是达到弹性设计的最佳方案。

2、在我们的设计中，应该允许行为可以被扩展，而不须修改现有的代码。

3、组合和委托可用于在运行时动态地加上新的行为。

4、除了继承，装饰者模式也可以让我们扩展行为。

5、装饰者模式意味着一群装饰者类， 这些类用来包装具体组件。

6、装饰者类反映出被装饰的组件类型（实际上，他们具有相同的类型，都经过接口或继承实现）。

7、装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。

8、可以用多个装饰者包装一个组件；也可以有多个ConcreteComponent。

9、 装饰者一般对组建的客户是透明的，除非客户程序依赖于组件的具体类型。

 10、继承是为了保证组件和装饰者的类型相同，不是为了获得父类的behavior，在runtime动态改变behavior是通过composition实现。