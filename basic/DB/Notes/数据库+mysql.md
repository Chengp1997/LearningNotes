# MySQL

![img](images/13526879-3037b144ed09eb88.png)

- **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
- **查询缓存：** 执行查询语句的时候，会先查询缓存（**MySQL 8.0 版本后移除，因为这个功能不太实用**）。
- **分析器：** 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- **优化器：** 按照 MySQL 认为最优的方案去执行。
- **执行器：** 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
- **插件式存储引擎** ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。

### 存储引擎

mysql有几种常见引擎，其中

**InnoDB**为默认引擎，并且**只有它是事务性的引擎。**

| 类型         | MyISAM                                                       | InnoDB                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 版本         | 5.5前默认引擎                                                | 5.7默认引擎                                                  |
| 支持的锁     | 只有表级锁                                                   | **表级锁，行级锁**（默认）（行锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，注意间隙锁的影响） |
| 事务         | 不支持事务                                                   | 支持事务（commit）回滚（rollback）崩溃修复能⼒(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表 |
| 并发         | 读写互相阻塞，读时阻塞写，写时阻塞读                         | 与事务隔离级别有关。看情况！                                 |
| 外键         | 不支持                                                       | **支持**                                                     |
| 速度         | 注重性能，很多时候速度很快，但是不得不考虑到一些事务的问题，所以InnoDB使用更多 |                                                              |
| 是否支持MVCC | 不支持                                                       | **支持**（MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。） |
| 适合场景     | select多                                                     | insert，update多                                             |
| 存储         | 存储成三个文件：.frm存储表定义，.MYD数据文件,.MYI索引文件。 也就是说，索引和文件是分开的。 | 表空间数据文件，日志文件（InnoDB 表的大小只受限于操作系统文件的大小）数据和索引是在一起的。 |

选用场景：**理论上，如果只有读需求，MyISAM速度会更快，但是实际上，基本上不会存在这样的场景了，所以其实大部分情况，它没有什么存在意义了**

MyISAM：

- 不需要事务支持（不支持）
- **并发相对较低（**锁定机制问题）
- 数据修改相对较少（阻塞问题），以读为主
- 数据一致性要求不是非常高

InnoDB

- 需要事务支持（具有较好的事务特性）
- 行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成
- 数据更新较为频繁的场景
- 数据一致性要求较高
- 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘 IO

**查询速度MyISAM快，原因在于：**

InnoDB 在做SELECT的时候，要维护的东西比MYISAM引擎多很多；

1）InnoDB 要缓存数据和索引，MyISAM只缓存索引块，这中间还有换进换出的减少

2）innodb寻址要映射到块，再到行，MyISAM记录的直接是文件的OFFSET，定位比INNODB要快

3）InnoDB 还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护

> 不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。

### 索引

**索引是什么**

简单来说，就想我们翻字典的时候前面的字母索引或者笔画索引。是为了方便查找数据而建立的。

Mysql使用的索引主要有：**BTree索引**，**哈希索引**

#### 哈希索引

顾名思义，哈希索引使用的底层结构为哈希表。**当查询的数据为单条的时候，可以使用哈希索引，因为快！**

#### BTree索引

什么是B+树 ：https://blog.csdn.net/chai471793/article/details/99563704

底层为 **B+树！**但是MyISAM和InnoDB中的树是有所不同的https://blog.csdn.net/qq_27607965/article/details/79925288

**MyISAM**

MyISAM存储的有3种文件。以.frm结尾的表定义文件；以MYD结尾的数据文件；以MYI结尾的索引文件。索引和数据文件时分开的，并且对应的文件会进行相应的压缩，对空间利用率更有利。

![MyISAM主键索引](https://img-blog.csdn.net/20150527164101257)

其B+树叶子结点存储的数据为数据记录的地址。

MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 

MyISAM的索引方式也叫做“**非聚集**”的

**InnoDB**

InnoDB存储的文件只有数据文件和它的日志文件。其和MyISAM不一样的地方在于，其B+树的叶子结点存储的数据为key+data。这种索引方式叫**聚集索引**（因此，使用该引擎，必须要有主键，如果不显式制定，则自动生成一个。）

![InnoDB主索引](https://img-blog.csdn.net/20150527165207200)

> 在根据主索引搜索时，直接找到**key**所在的节点即可取出数据；
>
> 在根据辅助索引查找时，则需要先取出主键的值，再⾛⼀遍主索引。 
>
> 因此，在设计表的时候，不建议使⽤过⻓的字段作为主键，也不建议使⽤⾮单调的字段作为主键，这样会造成主索引
>
> 频繁分裂。 



**为什么添加索引**

有时候为了，能够加速查询的速度，可以为数据库添加上索引，从而能够使查询的时候速度加快。

但是并不是索引快就所有都加索引好。因为添加索引后，当更新数据时，也需要更新索引文件，反而繁冗！

**创建索引**

添加PRIMARY KEY（主键索引）

```sql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```

2.添加UNIQUE(唯一索引)

```sql
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```

3.添加INDEX(普通索引)

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

4.添加FULLTEXT(全文索引)

```sql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```

5.添加多列索引

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

**左前缀原则**

当进行数据库查询的时候，为了加速，可以使用索引。但是索引并非随便使用便可以命中。例如创建 name，city 这个索引。当where时，使用name；name，city都可以命中索引。但是使用city无法命中索引。这就是左前缀原则。



https://zhuanlan.zhihu.com/p/73204847 关于索引的一些面试题：

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484848&idx=1&sn=77a0e6e82944ec385f5df17e91ce3bf2&chksm=cea24a7bf9d5c36d4b289cccb017292f9f36da9f3c887fd2b93ecd6af021fcf30121ba09799f&token=1082669959&lang=zh_CN&scene=21#wechat_redirect 一些小总结

https://blog.csdn.net/qq_36098284/article/details/79841094讲的比较清楚的有关索引是什么

### 事务

数据库操作，不可避免会发生事务性的操作。

事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏。

四大特性：**ACID**

![AID->C](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/AID-%3EC.png)

> 原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。

**并发问题：**

- 脏读（Dirty Read）：A读并改了数据a变为a‘，未提交保存；B此时读了数据a，其实应该读到a‘，a就是脏数据。
- 丢失修改（Lost to modify）：A读数据a，B也读数据a；A改成了a‘，并保存；B改成了b。A的更改丢失了。
- 不可重复读（unrepeatable read）:A读数据a，B也读数据a；B改成了b，此时A读数据时，读到的是b，这就导致一个事务内读到的数据不一样。
- 幻读（Phantom read）：和不可重复读类似，但是区别在于，幻读的更改为**插入/删除**了数据。此时对于正在事务中的进程来说，出现了本来应该不存在的数据，仿佛产生了幻觉。

**事务的隔离级别**

![image-20201210183813296](/Users/chengeping/Library/Application Support/typora-user-images/image-20201210183813296.png)

InnoDB默认为REPEATABLE-READ

InnoDB 存储引擎在 分布式事务 的情况下⼀般会⽤到 **SERIALIZABLE(**可串⾏化**)** 隔离级别

### 锁机制

具体可见此 https://blog.csdn.net/qq_34337272/article/details/80611486

#### 分类（按照粒度）

mysql中主要为两类锁，表级锁和行级锁。

- **表级锁**： MySQL中锁定 **粒度最⼤** 的⼀种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，**不会出现死锁**。其锁定粒度最⼤，**触发锁冲突的概率最⾼**，并发度最低，MyISAM和 InnoDB引擎都⽀持表级锁。
- **⾏级锁**： MySQL中锁定 **粒度最**⼩ 的⼀种锁，**只针对当前操作的⾏进⾏加锁**。 ⾏级锁能⼤⼤减少数据库操作的冲突。其加锁粒度最⼩，并发度⾼，但加锁的开销也最⼤，加锁慢，会出现死锁。

虽然行级锁很优秀，但是表级锁也是很必要的！

- 事务更新大表中的大部分数据直接使用表级锁效率更高；
- 事务比较复杂，使用行级索很可能引起死锁导致回滚。

**细分**

行级锁，表级锁可以继续细分，分为：共享锁（s）和排他锁（T）

共享锁：也可以叫做读锁。当事务A对对象X加共享锁时，只可以读它。其他事务只可以往上加S锁，但是不能加T锁。这就保证了其他事务可以并发读取，但是不可修改/删除。

排他锁：也可以叫做写锁。当事务A对对象X加排他锁时，允许A事务读取和修改该对象，其他事务不可往上面加任何锁，保证了不被人修改。

**再细分**

意向共享锁/意向排他锁

当事务准备访问某资源时，发现该资源被对象占用（已经被排他锁占用），可以加上一个意向锁。如果需要读取，则加意向共享锁；如果需要修改则加意向排他锁。

共享锁可以存在多个。排他锁只能存在一个。

#### InnoDB存储引擎算法

**InnoDB**存储引擎的锁的算法有三种：

- Record lock：单个⾏记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；

- Gap lock：间隙锁，锁定⼀个范围，不包括记录本身。对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。

- Next-key lock：record+gap 锁定⼀个范围，包含记录本身，可以解决幻读问题。

> 1. innodb对于⾏的查询使⽤next-key lock
>
> 2. Next-key lock为了解决Phantom Problem**幻读问题**
>
> 3. 当查询的索引含有唯⼀属性时，将next-key lock降级为record key
>
> 4. Gap锁设计的⽬的是为了阻⽌多个事务将记录插⼊到同⼀范围内，⽽这会导致幻读问题的产⽣
>
> 5. 有两种⽅式显式关闭gap锁：（除了外键约束和唯⼀性检查外，其余情况仅使⽤record lock）
>
> A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

### 优化方法

**大表优化**

https://segmentfault.com/a/1190000006158186

当数据过多，表过大时，会严重影响性能，可以如此做保证效率。

- 限定数据的范围限定数据的范围
- 读写分离，分主库，从库，一个写，一个读。
- 对表进行垂直拆分/水平拆分
  - 垂直拆分：简单地来说，就是把大表拆分成小表。优点：可以使得列数据变⼩，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。缺点：增加主键冗余，会引起Join操作
  - 水平拆分：也就是，分片。可以将数据分库，分表存放。



#### 池化技术

这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。

> 数据库连接**本质就是⼀个 socket 的连接**。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的 所以占⽤了⼀些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时**可以重⽤**这些连接。为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的⽹站应⽤程序的请求，既昂贵⼜浪费资源。
>
> 在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建⽴新的连接。如果使⽤了所有连接，则会建⽴⼀个新连接并将其添加到池中。 连接池还减少了⽤户必须等待建⽴与数据库的连接的时间。

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN%23rd

#### 分库分表后id如何处理？

需要一个全局id来维护所有的数据，生成全局id主要有以下几种方式

- **UUID**：不适合作为主键，因为太⻓了，并且⽆序不可读，查询效率低。⽐᫾适合⽤于⽣成唯⼀的名字的标示⽐如⽂件的名字。
- 数据库⾃增 **id** : 两台数据库分别设置不同步⻓，⽣成不重复ID的策略来实现⾼可⽤。这种⽅式⽣成的 id 有序，但是需要独⽴部署数据库实例，成本⾼，还会有性能瓶颈。
- 利⽤ **redis** ⽣成 **id :** 性能比较好，灵活⽅便，不依赖于数据库。但是，引⼊了新的组件造成系统更加复杂，可⽤性降低，编码更加复杂，增加了系统成本。
- **Twitter**的**snowflake**算法 ：Github 地址：https://github.com/twitter-archive/snowflake。
- 美团的**Leaf**分布式**ID**⽣成系统 ：Leaf 是美团开源的分布式ID⽣成器，能保证全局唯⼀性、趋势递增、单调递增、信息安全，⾥⾯也提到了⼏种分布式⽅案的对⽐，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的⼀篇⽂章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。

......

#### MySQl是如何处理语句的

这篇文章写得很详细，可以一看。

总的来说，需要经过：权限查询；缓存查询；分析；优化；执行几个步骤。

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd

#### mysql高性能优化建议

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd

#### mysql执行慢的原因

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN%23rd

ps：什么叫脏页？当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页； 内存数据写入磁盘后，内存页上的数据和磁盘页上的数据就一致了，我们称这个内存页为干净页。

