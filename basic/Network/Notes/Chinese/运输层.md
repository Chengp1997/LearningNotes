# 运输层

## TCP

https://blog.csdn.net/sinat_36629696/article/details/80740678

https://www.cnblogs.com/postw/p/9678454.html

传输控制协议, 顾名思义, 就是要对数据的传输进行一定的控制. 

### 协议报文

![Alt text](https://img-blog.csdn.net/20180620002403691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 源端口号/目的端口号: 表示数据从哪个进程来, 到哪个进程去.

- 4位首部长度: 表示该tcp报头有多少个4字节(32个bit)

- 6位保留: 顾名思义, 先保留着, 以防万一

- 6位标志位

  > URG: 标识紧急指针是否有效 
  >  ACK: 标识确认序号是否有效 
  >  PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走 
  >  RST: 要求重新建立连接. 我们把含有RST标识的报文称为**复位报文段** 
  >  SYN: 请求建立连接. 我们把含有SYN标识的报文称为**同步报文段** 
  >  FIN: 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为**结束报文段**

- 16位窗口大小: 

- 16位检验和: 由发送端填充, 检验形式有CRC校验等. 如果接收端校验不通过, 则认为数据有问题. 此处的校验和不光包含TCP首部, 也包含TCP数据部分. 

- 16位紧急指针: 用来标识哪部分数据是紧急数据.

### 连接机制

TCP在建立连接的时候，需要进行三次握手。结束连接的时候，需要进行四次挥手的过程

#### 三次握手

![Alt text](https://img-blog.csdn.net/20180620002440131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**流程简述**

客户端原先处于closed状态，服务端当建立TCB流量控制块后，就进入了LISTEN状态，随时等待客户端来连接。此时，当客户端想要进行连接来传输数据的时候，就会发生以下对话。

第一次：客户端告诉服务端，我要连接了。发送：SYN=1请求连接。并告知自己序列号seq=x

第二次：服务端告诉客户端，我收到了。发送：SYN=1，ACK=1.告知已经收到。自己的序列号为seq=y，确认序号为ack=x+1。

第三次：客户端告诉服务端，我收到了。发送：ACK=1告知已经收到，并且告诉当前自己序列号为x+1,确认序号为y+1.

之后，连接建立，客户端和服务端之间可以进行数据的传送。

**为什么要3次？**

第2，3次的作用都是在于告诉对方，我收到了你的信息，如此，保证了双方的通信都是正常的。

如果只有2次，没有第三次那么可能会发生这个情况：由于网络延迟，客户端第一次发送的请求连接报文服务端迟迟没有收到，于是又发送了一遍，此时客户端服务端完成了连接并且成功完成了数据的传输。当数据传输完成后，此时，先前的那一次请求突然服务端收到了，便会产生不必要的浪费。

4次也没必要，因为3次就保证了。

#### 四次挥手

![Alt text](https://img-blog.csdn.net/20180620002506635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**流程简述**

数据传输完毕后，双方都可以释放连接. 
此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接.

第一次：客户端告诉服务端，我要断开了。发送FIN状态码，告知准备断开连接。告知现在的序列号seq=u（即为最后一个数据的的最后一个字节加1）

第二次：服务端告诉客户端，我收到了，等我一下， 我要结束一下。发送ACK=1告知我收到了。并且告知对方自己当前的序列号v以及确认序列号u+1。

服务端做准备关闭工作。告知上层的应用程序，这个客户端的这个进程准备断开连接。服务端可能还有其他数据要传输，把剩下的数据传送完。并且进入close-wait状态

客户端继续等待服务端告知准备就绪准备关闭（等待FIN信号）。此时服务端如果有数据传输过来，客户端仍然需要继续接收。客户端进入等待2状态

第三次：服务端告诉客户端，准备好了，可以关闭了。发送FIN标识码告知,确认序号为v+1，自己的序列号为w

第四次：客户端告诉服务端，我收到消息了。关闭吧！发出ACK告知收到了，发出确认序号为w+1,自己的当前序列号为u+1。

**注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 而服务端在收到消息后，就进入closed状态**

**为什么要2*MSL才要结束**

> - 第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
> - 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

**如果已经建立了连接, 但是客户端突发故障了怎么办?**

> TCP设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

**如果服务端主动断开**

这里涉及到TIME_WAIT状态。如果服务端主动断掉连接，根据TCP的规定，主动断开的，会有TIME_WAIT状态，也就是上图的客户端那个样子！此时，处于TIME_WAIT状态的时候，服务端是不可以再次绑定同一个端口的。只有当服务端的该TCP连接完全断开，才能够重新被绑定。

### 可靠性保证机制

TCP采取了这些机制来保证数据能够安全稳定的到达对端。这是TCP的特点。

#### 确认应答机制

![这里写图片描述](https://img-blog.csdn.net/20180620002614358?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![编序号](https://img-blog.csdn.net/20180620002626330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
TCP会为每个字节都进行编码。而ACK作用就是告知对方，我收到了多少字节。

例如，客户端发送到1005字节的数据包，服务器返回序列号1003，说明只收到了1-1002的数据，1003，4，5并没有收到。

客户端会根据返回的数据号，从1003字节重新开始传送。

#### 超时重传机制

当使用TCP协议来进行传输的时候，可能会产生丢包问题。在一定时间内，迟迟未收到需要的数据包的时候，便会发生超时重传。

![这里写图片描述](https://img-blog.csdn.net/20180620002645335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![这里写图片描述](https://img-blog.csdn.net/20180620002717106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

情况1:客户端在向服务端传送数据的过程中可能由于网络问题，无法到达。

当客户端在一定时间间隔内（超时！）未收到确认应答的时候，会认为数据包已经丢失。此时会重新向服务端发送一次相同的数据包。

情况2:客户端发送的数据到达服务端了，但是确认应答消息却在传输的过程中丢失了。

一定时间间隔内客户端未收到应答时，会重新发送数据包给服务器。此时，为了产生不必要浪费，服务端可能会应用的上跳所述的 **确认应答机制**保证了资源部被浪费。当完成，则返回新的应答。

**如何确认时间间隔？**

> 影响超时重传机制协议效率的一个关键参数是重传超时时间（RTO，Retransmission TimeOut）。RTO的值被设置过大过小都会对协议造成不利影响。
> 　　（1）RTO设长了，重发就慢，没有效率，性能差。
> 　　（2）RTO设短了，重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。
> 　　连接往返时间（RTT，Round Trip Time），指发送端从发送TCP包开始到接收它的立即响应所消耗的时间。

这个时间间隔，如果时间太长，则影响效率；太短，重传频繁。

动态计算时间间隔。以Linux为例。500ms为一个单位。第一次500ms重发一次；如果还没有，500*2再发一次。指数增长。直到一定次数，还没有收到应答，则认为已经挂掉。

#### 滑动窗口机制

**概念**：

窗口大小指的是无需等待确认应答就可以继续发送数据的最大值. 

例如，下图的窗口大小为4000字节。

当发送前面四个段的时候（在滑动窗口内），无需等待ACK的到达，就可以继续发送。

当第一个ACK到达， 窗口向后滑动。因此叫做滑动窗口。

![这里写图片描述](https://img-blog.csdn.net/20180620002740304?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![这里写图片描述](https://img-blog.csdn.net/20180620002804100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

如上图，当完成一段后，窗口向后 进行一次滑动。

> 操作系统内核为了维护这个滑动窗口, 需要开辟发送缓冲区来记录当前还有哪些数据没有应答 
>  只有ACK确认应答过的数据, 才能从缓冲区删掉. 

**丢包恢复机制**

在网络传输过程中，可能会丢失数据包。此时可以通过一下的方式来保证信息传输。主要有两种可能

情况一：数据包安全送达，但是应答消息消息丢失了。这种情况，数据已经保证收到了。这种情况，部分ACK丢失没关系，因为可以根据后续的ACK来确认数据是否收到了。

![这里写图片描述](https://img-blog.csdn.net/20180620002838988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

情况2:如下图，数据在传输过程中，丢失了其中一个包（1001-2000）。

主机B收到1000数据包后，只要还没收到1001数据包，就会一直发送需要1001的数据包的应答。

主机A在连续收到**3次**1001应答时，就会将对应的数据包重新发送给主机B。

当主机B收到1001数据包后，会将7001ACK发送回去（之前2001-7000已经发送过了，存储在接收端的系统缓存中）

![这里写图片描述](https://img-blog.csdn.net/201806200028220?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 流量控制机制

接收端处理数据的速度是有限的. 如果发送端发的太快, 导致接收端的缓冲区被填满, 这个时候如果发送端继续发送, 就会造成丢包, 进而引起丢包重传等一系列连锁反应. 

TCP支持根据接收端的处理能力, 来决定发送端的发送速度. 这个机制就叫做 **流量控制(Flow Control)**

![这里写图片描述](https://img-blog.csdn.net/20180620002859330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

接收端会将自己的可接受缓冲区大小（也就是当前自己的窗口大小），放在TCP的窗口大小报文段中，传回给发送端，也就是ACK应答中。发送端就知道，服务端当前可以接收多少数据而不会堵塞。

窗口大小越大，说明现在吞吐量大。

接收端发现自己处理不过来了，缓冲区快满了，就会将自己的窗口大小设置为更小的值，通知对方。当缓冲区满的时候，就会通知0，让对方暂时不发送了。

此时如上图。如果超过了重发超时的时间，发送端还没有接收到接收端的窗口通知，就会自己发送一个**窗口探测的报文**看看是否可以进行发送了。

如果接收端缓冲区处理完毕，将数据清理，就会想发送端发送窗口更新的通知。

注意，由于窗口更新通知有可能回在传送中丢失，为了保证正常通信，发送端回定时发送窗口探测报文。

#### 拥塞控制机制

流量控制能够保证端端之间的数据能够及时接收，抑制速率，保证了处理。

但是当数据在传输过程中，有可能由于网络拥堵的问题，造成数据根本都难以到达。如果在不知道网络情况下就发送大量数据，有可能会造成更严重的拥堵问题。拥塞控制机制就是用来处理这个问题的。

> 拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制。TCP拥塞控制4个核心算法：**慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fast retransmit）、快速回复（fast recovery）**。拥塞窗口（cwnd，congestion window），其大小取决于网络的拥塞程度，并且动态地在变化。
>
> **慢开始算法**
>
> 思路：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
>
> > 这里引入一个概念：**拥塞窗口**
> >
> > - 发送开始的时候, 定义拥塞窗口大小为1; 
> > - 每次收到一个ACK应答, 拥塞窗口加1; 
> > - 每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, **取较小的值作为实际发送的窗口**
>
> > 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：
> > 当cwnd < ssthresh时，使用**慢开始算法**。
> > 当cwnd > ssthresh时，改用**拥塞避免算法**。
> > 当cwnd = ssthresh时，**慢开始与拥塞避免算法任意**。
>
> **拥塞避免算法**
>
> 思路：让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送发的拥塞窗口cwnd加1，而不是加倍。（线性）
>
> 无论是在慢开始阶段还是在拥塞避免阶段，**只要发送方判断网络出现拥塞，**就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：
>
> **快重传，快恢复**
>
> **快速重传(Fast retransmit)**要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。
> 快重传算法规定，发送方**只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段**，而不必继续等待设置的重传计数器时间到期。
>
> **快速恢复(Fast Recovery)**
> （1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
> （2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。
>
> ```
> 发送方窗口的上限值 = Min [ rwnd, cwnd ]
> 当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。
> 当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大
> ```

![image.png](https://upload-images.jianshu.io/upload_images/11281208-d76e6c85873fbef8.png?imageMogr2/auto-orient/strip)

拥塞控制的具体过程如下：
（1）TCP连接初始化，将拥塞窗口设置为1
（2）执行慢开始算法，cwnd按指数规律增长，直到cwnd=ssthresh时，开始执行拥塞避免算法，cwnd按线性规律增长
（3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行

![这里写图片描述](https://img-blog.csdn.net/20180620002915553?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NjI5Njk2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

少量的丢包, 我们仅仅是触发超时重传; 
 大量的丢包, 我们就认为是网络拥塞; 
 当TCP通信开始后, 网络吞吐量会逐渐上升; 
 随着网络发生拥堵, 吞吐量会立刻下降.

**流量控制VS拥塞控制**

流量控制保证了数据到达接收端的时候可以及时地处理接收而不造成浪费。

拥塞控制则保证了数据在网络中传递时不会发生堵塞而能够快速地到达接收端。

#### 延迟应答

有时候，数据处理的速度可能非常快，不到几ms就处理完毕，便可以清空自己的当前的缓存，而预留更大的滑动窗口。窗口越大，吞吐量越大，效率越高。

因此，当数据到达接收端的时候，可以延缓应答，让缓存变大，从而保证效率。

机制大概是：

> - 数量限制: 每隔N个包就应答一次 
> - 时间限制: 超过最大延迟时间就应答一次 
>
> 一般N取2，最长延迟时间为200ms

#### 面向字节流

TCP是全双工的，那么一个连接即可以读数据，也可以取数据。有一个发送缓冲区，和一个接收缓冲区。意味着两种方式可以同步。

#### 粘包问题

 “包”, 是指`应用层的数据包`. 

产生原因：没有边界！

解决方法：

> 对于定长的包 
>  \- 保证每次都按固定大小读取即可 
>  例如上面的Request结构, 是固定大小的, 那么就从缓冲区从头开始按sizeof(Request)依次读取即可 
>
> 对于变长的包 
>  \- 可以在数据包的头部, 约定一个数据包总长度的字段, 从而就知道了包的结束位置 
>  还可以在包和包之间使用明确的分隔符来作为边界(应用层协议, 是程序员自己来定的, 只要保证分隔符不和正文冲突即可)

#### 快重传机制



####  TCP 协议如何保证可靠传输

1. 应⽤数据被分割成 TCP 认为最适合发送的数据块。

2. TCP 给发送的每⼀个包进⾏**编号**，接收⽅对数据包进⾏排序，把有序数据传送给应⽤层。

3. **校验和**： TCP 将保持它⾸部和数据的检验和。这是⼀个端到端的检验和，⽬的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报⽂段和不确认收到此报⽂段。

4. TCP 的接收端会丢弃重复的数据。

5. **流量控制**： TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅**降低发送的速率**，防⽌包丢失。TCP 使⽤的流量控制协议是可变⼤⼩的**滑动窗⼝协议**。 （TCP 利⽤滑动窗⼝实现流量控制）

6. **拥塞控制**： 当⽹络拥塞时，减少数据的发送。

7. **ARQ**协议： 也是为了实现可靠传输的，它的基本原理就是每发完⼀个分组就停⽌发送，等待对⽅确认。在收到确认后再发下⼀个分组。

8. 超时重传： 当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段。

## UDP

**User Datagram Protocol，用户数据报协议**

UDP是**传输层**的协议，功能即为在IP的数据报服务之上增加了最基本的服务：**复用**和**分用**以及**差错检测**。

UDP提供**不可靠**服务，具有TCP所没有的**优势**：

- UDP**无连接**，时间上**不存在建立连接需要的时延**，速度快，适合需要高速的应用。
- **UDP没有拥塞控制**能够容忍部分数据的丢失。
- UDP**常用一次性传输比较少量数据的网络应用**，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的