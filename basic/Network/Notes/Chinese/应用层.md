# 应用层

任务是通过应⽤进程间的交互来完成特定⽹络应⽤。应⽤层协议定义的是应⽤进程（进程：主机中正在运⾏的程序）间的通信和交互的规则。对于不同的⽹络应⽤需要不同的应⽤层协议。

## http协议

##### **简介**：

超文本传输协议（英文：**H**yper**T**ext **T**ransfer **P**rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

##### **特点**

- HTTP是**无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。这是http的一种特性。（这里相比较于长短连接可以这么理解：无连接是一个特性，它意味着期待对于每一次请求都有一个对应的解答。长短连接则是其一种实现的方式。虽然说的是长连接，但是对于http来说，就是建立连接并等待回应，它并不知道是长还是短连接。因此！http是无连接的。）

> http的长连接实际上是tcp的长连接。因此对于http来说，毫不知情。http的长连接是是现在http之外的，因此与它无关，依然是无连接的。

- HTTP是**无状态**：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。（如果要保存状态，则使用cookies或者session。具体使用方式见后文）

##### **工作原理**

简述：

首先客户端会和服务端端口（默认80）建立一个TCP套接字连接。

然后发送http请求报文，请求所需要的资源。

服务端解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。

若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

##### **请求报文**

![http请求报文](/Users/chengeping/Documents/LearningMaterial/profession/计算机网络/http请求报文.png)

样例：

![请求报文样例](/Users/chengeping/Documents/LearningMaterial/profession/计算机网络/请求报文样例.jpg)

- 请求行：包含请求方法（GET，POST最常用）；请求对应的URL地址（它和报文头的Host属性组成完整的请求URL）；使用什么样的协议版本。1.0为短连接，1.1位长连接。
- 请求头部：包含了，接受什么样的资源方式，接受的语言，以及使用的浏览器，使用的cookie id等。
  - Accept：告诉服务端，客户端可接受的MIME数据类型。
  - User-Agent：产生请求的浏览器类型。
  -  Referer：表示这个请求是从哪个URL过来的，假如你通过google搜索出一个商家的广告页面，你对这个广告页面感兴趣，鼠标一点发送一个请求报文到商家的网站，这个请求报文的Referer报文头属性值就是http://www.google.com。
  - Cache-Control：对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。
  - cookie：客户端的Cookie就是通过这个报文头属性传给服务端的。服务端是怎么知道客户端的多个请求是隶属于一个Session呢？注意到后台的那个jsessionid = 5F4771183629C9834F8382E23木有？原来就是通过HTTP请求报文头的Cookie属性的jsessionid的值关联起来的！（当然也可以通过重写URL的方式将会话ID附带在每个URL的后面哦）。
  - Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
- 请求体：这部分，只有请求方法为post的时候才会出现。

##### **响应报文**

![http响应报文样例](/Users/chengeping/Documents/LearningMaterial/profession/计算机网络/http响应报文样例.jpg)

- 响应行包含了：http协议的版本，以及响应的状态码和描述

- 响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。

  > 设置HTTP响应头往往和状态码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401(Unauthorized)状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。

  - Allow：服务器支持哪些请求方法(如GET、POST等)。
  - Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。
  - Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。
  - Content-  Type：表示后面的文档属于什么MIME类型。
  - Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。
  - Last-Modified：文档的最后改动时间。
  - Refresh：告诉浏览器隔多久刷新一次，以秒计。
  - Server：服务器通过这个头告诉浏览器服务器的类型。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。Servlet一般不设置这个值，而是由Web服务器自己设置。
  - Transfer-Encoding：告诉浏览器数据的传送格式。

- 响应体：响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。

##### 请求方法

请求方法除了常见的GET，POST之外，还有

| 请求方法 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| GET      | 向指定的资源发出“显示”请求(URL可见请求数据)。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 |
| POST     | 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 |
| HEAD     | 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。 |
| PUT      | 向指定资源位置上传其最新内容。                               |
| DELETE   | 请求服务器删除Request-URI所标识的资源。                      |
| TRACE    | 回显服务器收到的请求，主要用于测试或诊断。                   |
| OPTION   | 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 |
| CONNECT  | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 |

> 1. 方法名称是**区分大小写的**。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。
> 2. HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源*。*

**GET和POST的区别**

- **GET提交的数据会放在URL之后，**也就是请求行里面，以?分割URL和传输数据，参数之间以&相连，如EditBook?name=test1&id=123456.（请求头里面那个content-type做的这种参数形式） POST方法是把提交的数据放在HTTP包的请求体中.
- GET提交的**数据大小有限制**（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
- **安全性**：POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，

##### 状态码

状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。

常见状态码

- 200 OK：客户端请求成功。
- 302/307：临时重定向，指出请求的文档已被临时移动到别处, 此文档的新的url在location响应头中给出
- 303 See Other ：我把你redirect到其它的页面，目标的URL通过响应报文头的Location告诉你。
- 304 Not Modified ：告诉客户端，你请求的这个资源至你上次取得后，并没有更改，你直接用你本地的缓存吧，我很忙哦，你能不能少来烦我啊！ 
- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
- 403 Forbidden：服务器收到请求，但是拒绝提供服务。
- 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
- 500 Internal Server Error：服务器发生不可预期的错误。
- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。

##### http如何记住状态的

http是无状态的协议。如果想要能够让网页记住当前用户的登录状态等信息，可以通过cookies机制活着session机制来进行。

**cookies机制**

cookie是一种客户端存储的机制，用户状态信息保存在客户端本地。

Set-Cookie ：服务端可以设置客户端的Cookie，其原理就是通过这个响应报文头属性实现的。

- 最开始时，当服务器需要设置cookie的时候，客户端发送请求给服务器的时候，服务器会为客户端设置一个cookie，
- 并通过set-cookie这个响应报文头的属性告诉客户端这个cookie id，有效时间，客户端将信息存储在这个cookie中并将这个cookie存储在浏览器中。
- 当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。
- 服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。

如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。

```java
Cookie cookie = new Cookie("username","helloweenvsfei");   // 新建Cookie
cookie.setMaxAge(0);                          // 设置生命周期为0，不能为负数
response.addCookie(cookie);                    // 必须执行这一句 输出到客户端
```

https://www.cnblogs.com/limengyao/p/8604379.html

**session机制**

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

- 当服务器需要保存用户信息的时候，首先检测客户端的请求是否包含session id
  - 如果包含，说明已经有，则查找散列表中对应的session，并读取信息
  - 如果不包含，则创建一个session，并将这个session id返回给客户端，之后客户端的请求就可以包含这个session id供服务端检索。
- 对于客户端session的保存，可以使用cookie来实现。活着存储在url中，或者隐藏在表单中。

关闭浏览器是不会让session消失的。服务器为session设置了一个失效时间，只有超过了这个时间才会失效。从而删除而节省空间。

*java中的session*

对于java程序，使用的是**javax.servlet.http.HttpSession** 来实现session

- 创建：session是直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建，session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。
- 删除：a.程序调用HttpSession.invalidate();或b.距离上一次收到客户端发送的session id时间间隔超过了session的超时设置;或c.服务器进程被停止（非持久session）

| cookie                                                       | session                                                      |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **存放在客户的浏览器上**                                     | **数据放在服务器上**                                         |
| **cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗** | **相对安全**                                                 |
| **单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。** | **Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型** |

https://www.cnblogs.com/l199616j/p/11195667.html

##### 长连接，短连接

Http1.0 默认使用短连接。意味着，每请求一次资源就需要建立一次连接，当资源传输到达就断开连接。意味着，解析web页面时，每遇到一个新的资源就要重新建立一个会话。

Http1.1 使用长连接。此时报文会增加一个属性：Connection:keep-alive。当使用长连接的时候，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

https://www.cnblogs.com/gotodsp/p/6366163.html

| 长连接                                            | 短连接                                                       |
| ------------------------------------------------- | ------------------------------------------------------------ |
| 省去较多的TCP建立和关闭的操作，减少浪费，节约时间 | 管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段 |
| 连接过多时，服务器可能超负荷，需要管理            | 请求频繁时，浪费时间和带宽                                   |

## HTTPS

![HTTPS](https://segmentfault.com/img/bVp65j)

本质就是http，只是在传输到tcp的时候，需要进行ssl/tls加密，保证了安全性。

缺点是，因为要加密，耗时可能会长一点。

关于加密方法：http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html

## DNS

运行在UDP上

https://blog.csdn.net/jiayu5100687/article/details/81985968 具体解析方式见次网址

DNS解析过程涉及将主机名（例如www.example.com）转换为计算机友好的IP地址（例如192.168.1.1）

![DNS](/Users/chengeping/Documents/LearningMaterial/profession/计算机网络/DNS.jpg)

![DNS解析过程](https://segmentfault.com/img/bVDM45?w=1928&h=1248)

上图为dns的解析www.google.com过程。首先，查询本地域名服务器是否有该网址的域名。如果本地缓存中未找到，则先询问根域名服务器。如果还未找到，则寻找com顶级域名服务器。以此类推，最后找到该网址的域名。

DNS的域名解析时一个**从右向左**的过程。根域名服务器得到的是.  因此，解析过程实际上为.->.com->google.com.->www.google.com

**DNS优化**

DNS通过高速缓存来保证优化。按照距离浏览器远近，主要为：浏览器缓存；系统缓存；路由器缓存；IPS服务器缓存；根域名服务器缓存；顶级域名服务器缓存；主域名服务器缓存等。查询时，也是按照这个顺序来查找。

**DNS负载均衡**

实际上服务器有很多台，每次DNS可能会根据负载或者位置距离等来为你分配合适的机器，这就是DNS负载均衡，或者说叫DNS重定向。

应用例如：CDN技术

## ARP

地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。

https://blog.csdn.net/lm409/article/details/80299823

具体查询方式见下面面试题一

## 面试题解

##### 面试题一：从输入URL到页面显示发生了什么

https://www.imooc.com/article/23575?block_id=tuijian_wz

https://segmentfault.com/a/1190000006879700

- 寻找IP地址（DNS）：
  - 先查看浏览器缓存是否有该url的ip缓存
  - 如果没有，则查看操作系统dns中是否有对应的ip
  - 依旧没有就查看本地的域名服务器是否有
  - 如果还是没有，则查找根服务器，依此类推，知道找到对应的网址。
- 通过IP地址寻找MAC地址（ARP）：
  - 首先发送主机A**查看自己的arp表**是否有该ip地址。如果有则返回对应的mac地址
  - 如果没有该ip地址，则缓存该报文，然后**广播**发送arp请求报文询问。只有对应ip的主机会回应。
  - 对应主机会将ip与自己的ip比对，如果匹配成功，则会将发送主机的ip地址和MAC地址存储起来，并用**单播的方式**，告诉请求主机A自己的地址。
  - 请求主机A收到对应主机的响应报文后，将对应的地址存储到自己的缓存中，并将数据发送出去。

> 小好奇：为什么有了ip还要有mac：

> 这个涉及一些历史问题，因为一开始没有互联网的时候就只有mac地址，还不存在ip地址。后来互联网越来越大之后，发现mac地址找起来太麻烦，并且耗时也越来越久，就发明了ip地址。

- 进行TCP的连接：三次握手（见TCP部分）。连接完成后就可以双方进行数据的传输。
- 客户端发送请求，等待服务器回应
- 服务器收到请求，并作出相对应的响应。
- 客户端得到响应，并获取对应的资源文件
- 渲染页面
- 连接结束（四次挥手）

