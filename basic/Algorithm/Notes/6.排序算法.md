# Sorting

## Terms

**Stable Sort**：在输入列表中，任意两个相等数字的次序（比如r[i]在r[j]之前），排序后次序不变----**稳定的**

**Online algorithm**：是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入

​	插入排序

**offline algorithm**：在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。

**P：** polynomial ,   polynomial or less  能在这个时间内解决的算法

**NP:** non-deterministic  polynomial， 

## Merge Sort

#### Intro

分-治-合

“recursively！combine！”

将数组等划分，对于每个小部分，都自己排序。最后将各个小部分合并成答案。

对于每个分列，从头开始比较

//具体流程，详见

https://www.cnblogs.com/chengxiao/p/6194356.html#undefined

#### 复杂度

假设被排序的数列中有N个数，合并操作的时间复杂度为O(n), 完全二叉树的深度为|log2n|,因此，为**O(nlogn)**

#### 稳定性

稳定的，按照一个方向来，不会出错！

#### 空间

需要多出merge的空间！**NOT in-place**  多了n空间

需要多增加的那个temp数组大小，以及递归时压入栈的空间大小

#### 实现

```java
package com.company.MergeSort;

public class MergeSort {
    public static void main(String args[]){
        int arr[]={6,9,1,4,5,2,88};
        mergeSort(arr);
        for (int i=0;i<arr.length;i++){
            System.out.print(arr[i]+"  ");
        }
    }

    public static void mergeSort(int arr[]){
        int temp[]=new int[arr.length];
        mergeSort(arr,0,arr.length-1,temp);
    }

    private static void mergeSort(int sortArr[],int start,int end,int tempArr[]){
        if (start<end) {//此为结束条件，直到不能再分了，只剩1个结点了!
            int mid = (start + end) / 2;
            mergeSort(sortArr, start, mid, tempArr);//分左侧
            mergeSort(sortArr, (mid+1), end, tempArr);//分右侧
            merge(sortArr,start,mid,end,tempArr);//开始合并，根据切分的，开始合并两个元素
        }
    }

    public static void merge(int sortArr[],int start,int mid,int end,int temArr[]){
        int i=start;
        int j=mid+1;
        int temp=0;
        while (i<=mid&&j<=end){
            if (sortArr[i]<sortArr[j]){
                temArr[temp++]=sortArr[i++];
            }else {
                temArr[temp++]=sortArr[j++];
            }
        }

        //[2,4,7,8],[1,3,5,6]
        //如上，将上述排完位置后，会剩下[,,7,8][,,,]要把剩下的塞进去
        while (i<=mid){
            temArr[temp++]=sortArr[i++];
        }
        while (j<=end){
            temArr[temp++]=sortArr[j++];
        }
        //将所有都塞完后，copy回原数组
        temp=0;
        while (start<=end){
            sortArr[start++]=temArr[temp++];
        }


    }
}
```

归并排序是一个相当**“稳定”**的算法对于其它排序算法，比如希尔排序，快速排序和堆排序而言，这些算法有所谓的最好与最坏情况。而归并排序的时间复杂度是固定的，它是怎么做到的？

**然后就又要回到比较原始的问题了，归并排序它为什么会快呢？**

想回答这个问题可以先想一下之前说过的提高排序速度的两个重要的途径：**一个是减少比较次数，一个是减少交换次数。**

对于归并排序而言，我们来从之前的例子应该可以看到，**两个数组的合并过程是线性时间的**，也就是说我们每一次比较都可以确定出一个元素的位置。这是一个重要的性质。

我们来看一个可以用一个例子来体会一下假如有这样一个数组｛ 3，7，2，5，1，0，4，6 ｝，

冒泡和选择排序的比较次数是25次。

直接插入排序用了15次。

而归并排序的次数是相对稳定的，由我们上面提到的比较次数的计算方法，我们的例子要合并4对长度为1的，2对长度为2的，和1对长度为4的。

归并排序的**最多**的比较次数为4 * 1 + 2 * 3 + 7 = 17次。（感谢**@icyjiang的提醒**）

## 快速排序

#### 介绍

https://www.cnblogs.com/skywang12345/p/3596746.html

具体过程祥见此

#### 稳定性

快速排序是**不稳定的算法，**它不满足稳定算法的定义。
*算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！*

#### 复杂度

**快速排序的时间复杂度在最坏情况下是O(N^2)，平均的时间复杂度是O(N*lgN)。**
这句话很好理解：假设被排序的数列中**有N个数**。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。
(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，**它需要遍历的次数就是二叉树的深度**，而根据完全二叉树的定义，**它的深度至少是lg(N+1)**。因此，快速排序的遍历次数最少是lg(N+1)次。
(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。

#### 空间

**不是in-place算法**

每次分成子列的时候，都需要压入栈，是占用空间的。

#### 实现

```java
package com.company.QuickSort;

public class QuickSort {
    public static void main(String args[]){
        int arr[]={4,5,9,7,2,3,1,6};
        sort(arr,0,arr.length-1);
        for (int i=0;i<arr.length;i++){
            System.out.print(arr[i]+"  ");
        }
    }

    public static void sort(int sortArr[],int start, int end){
        if (start<end){
            int i=start;//左指针
            int j=end;//右指针
            int base=sortArr[start];//此处将0位置的作为基准
            while (i<j){//当指针还未重合时
                while (i<j&&sortArr[j]>base){//当未找到比base小的值时，减小
                    j--;
                }
                if (i<j){//找到比base小的值时，将j指针的值赋给i指针的位置
                    sortArr[i++]=sortArr[j];
                }
                while (i<j&&sortArr[i]<base){//同上
                    i++;
                }
                if (i<j){
                    sortArr[j--]=sortArr[i];
                }
            }
            sortArr[i]=base;//这一步要记得把中间的位置变成base
            //此处，之后不停分着sort，直到每个小区间不可再分地排序完毕
            sort(sortArr,start,i-1);
            sort(sortArr,(i+1),end);
        }
    }
}
```

## 插入排序

#### 介绍

- 每一步，都将a[j]位置插入到前面的对应位置上去
- 重复n-1次，得到排序数列

#### 稳定性

**稳定**。收到就能排序

#### 复杂度

直接插入排序的时间复杂度是**O(N^2)**。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1！因此，直接插入排序的时间复杂度是O(N2)。**

**worst case**:  倒序了!  比较1+2+3+++++n-1 次      n^2

**Best** **case:** 排好了！

#### 空间

**in-place** 需要常量的内存空间。

#### 实现		

```java
public class InsertionSort {
    public static void insertionSort(int a[]){
        //从1位的数字开始，向前面一个一个找
        for (int i=1;i<a.length;i++){
            for (int j=i-1;j>=0;j--){
                if (a[j]>a[j+1]){//如果前面的数字更小，就交换！
                    swap(a,j,j+1);
                }
            }
        }
    }
    public static void swap(int a[],int x,int y){
        int temp=a[x];
        a[x]=a[y];
        a[y]=temp;
    }

    public static void main(String args[]){
        int a[]={4,67,2,4,1,3,6};
        insertionSort(a);
        for (int i=0;i<a.length;i++){
            System.out.println(a[i]);
        }
    }
}
```

## 冒泡排序

这个。。自己见往常自己写的

## 堆排序

#### 堆的介绍

先理解堆！

此处详见此大佬博客

二叉堆：http://www.cnblogs.com/skywang12345/p/3610187.html

左倾堆：http://www.cnblogs.com/skywang12345/p/3638327.html

斜堆：    http://www.cnblogs.com/skywang12345/p/3638493.html

二项堆：http://www.cnblogs.com/skywang12345/p/3655900.html

斐波那契堆：http://www.cnblogs.com/skywang12345/p/3659060.html

堆：有点像二叉树，所有叶子都从左边加到右边，一层满了下一层，只有最下面一层是不满的。每个子树都是二叉堆。树的每个父结点都比子节点大。

**堆的删除**

每次都从root开始删除。将最后一个元素移动到空位上

![1555248781346](C:\Users\Emily_Chen\AppData\Roaming\Typora\typora-user-images\1555248781346.png)

如上，删除根节点后，开始挪动，每次把最大的挪动上来。最后将最后一个元素挪动到空位。

**应用：能够此方法，通过不断删除根节点的root，然后进行调整来获得有序队列！。**

**堆的创建**

先将数组变成树，然后使用FixHeap算法，即调整算法，变成最大堆！

**基本思想**

- 初始化堆：将数列a[1...n]构造成最大堆。
  - 将数组先按顺序构造成树
  - 使用FixHeap算法，将该数组转换成最大堆
- 交换数据：将a[1]和a[n]交换，使a[n]是a[1...n]中的最大值；然后将a[1...n-1]重新调整为最大堆。 接着，将a[1]和a[n-1]交换，使a[n-1]是a[1...n-1]中的最大值；然后将a[1...n-2]重新调整为最大值。 依次类推，直到整个数列都是有序的。
  - 具体过程见上文堆的删除。方式相同。

具体过程详见：https://www.cnblogs.com/skywang12345/p/3602162.html

#### 稳定性

不稳定算法！，交换时，多乱啊！它在交换数据的时候，是比较父结点和子节点之间的数据，所以，即便是存在两个数值相等的兄弟节点，它们的相对顺序在排序也可能发生变化。

#### 复杂度

**堆排序的时间复杂度是O(NlgN)。**
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？
堆排序是采用的二叉堆进行排序的，二叉堆就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。最多是多少呢？由于二叉堆是完全二叉树，因此，它的深度最多也不会超过lg(2N)。因此，遍历一趟的时间复杂度是O(N)，而遍历次数介于lg(N+1)和lg(2N)之间；因此得出它的时间复杂度是O(NlgN)。

#### 空间

很明显。。。emmm, 一直只有这个数组啊！ in place！

## 计数排序

#### 介绍

详细见 https://blog.csdn.net/developer1024/article/details/79770154

步骤很简单，需要一个多余的数组B，其中第i个数在数组B中的值是待排序数组中value=i 的数字的个数



## 桶排序

#### 介绍

详细见 https://blog.csdn.net/developer1024/article/details/79770240

一个比较简单的算法，分为3个步骤：Distribute, sort buckets, concatenate buckets. 可以理解成升级版计数排序

即，将各个要排序的数据放到不同的桶中，分别在各个桶中排序，将各个桶的数据集合

桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。

然后基于某种映射函数f ，将待排序列的关键字 k 映射到第i个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。

接着将各个桶中的数据有序的合并起来 : 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]….B[M] 中的全部内容即是一个有序序列。

> 补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数

#### 稳定性

稳定的！都是按顺序来的

#### 复杂度

分：O(n) 每个数字都要归类

治：O(k*(n/k)log(n/k))=O(nlog(n/k)) k个桶，每个桶中自己排序

合：O(n) 每个数字都要合

时间复杂度   O(nlog(n/k))

#### 空间

kn  k个桶（使用array）

2n+k   用链表

**Trade-off between time and space**

k 变大，速度虽然快了，但是空间也变大了

桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。

## 基数排序（radix sort）

#### 介绍

将数字，按每个位进行bucket sort（Least significant digit）/ counting sort（Most significant digit）

详细见 https://blog.csdn.net/developer1024/article/details/79770321

## 比较

| algorithm | worst case | average case | space                                                        | stable |
| --------- | ---------- | ------------ | ------------------------------------------------------------ | ------ |
| 插入排序  | O(N^2)     | O(N^2)       | IN-PLACE（只需要一个temp）                                   | stable |
| 快速排序  | O(N^2)     | O(NlogN)     | No                                                           | X      |
| 归并排序  | O(nlogn)   | O(NlogN)     | No  需要多增加的那个temp数组大小，以及递归时压入栈的空间大小 | stable |
| 堆排序    | O(nlogn)   | O(NlogN)     | IN-PLACE                                                     | X      |
| 桶排序    |            |              | No                                                           | stable |

nlogn是最快的比较排序算法！！！



## Reference

https://blog.csdn.net/developer1024/column/info/21084
