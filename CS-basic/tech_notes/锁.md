# 锁

悲观锁、乐观锁、独占锁、共享锁、公平锁、非公平锁、分布式锁、自旋锁

### 悲观锁乐观锁

#### 悲观锁

每次去拿数据的时候都**认为别人会修改**，所以**每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会block直到它拿到锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

**在整个数据处理过程中，将数据处于锁定状态。**

实现往往依靠数据库本身锁

#### 乐观锁

就是很乐观，每次去拿数据的时候**都认为别人不会修改，所以不会上锁**，但是在更**新的时候会判断一下在此期间别人有没有去更新这个数据**，可以使用版本号等机制。

乐观锁**适用于多读的应用类型**，这样可以提高吞吐量，

#### 乐观锁和悲观锁的区别

**乐观锁**适用于**读**多的场景。这样可以省去大量开销。可以通过**版本控制**去实现，发生冲突后，上层会不停**retry**。

悲观锁适用于冲突比较多的场景。表现例如数据库的表锁；行锁。

#### 什么是MVCC？

**只有在InnoDB引擎下存在**，MVCC是为了实现事务的隔离性，**通过版本号，避免同一数据在不同事务间的竞争**，所说的乐观锁只在事务级别未提交锁和已提交锁时才会生效

多版本并发控制，保证数据操作在多线程过程中，保证事务隔离的机制，可以降低锁竞争的压力，保证较高的并发量。

在每开启一个事务时，会生成一个事务的版本号，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题

> 优点
>
> - 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
> - 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题
>
> 总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：
>
> - MVCC + 悲观锁
>    MVCC解决读写冲突，悲观锁解决写写冲突
> - MVCC + 乐观锁
>    MVCC解决读写冲突，乐观锁解决写写冲突
>    这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

具体原理可见此：https://www.jianshu.com/p/8845ddca3b23

### 独占锁共享锁

#### 独占锁

也可叫写锁。

独占锁也叫排他锁，即是持有锁的线程**只有一个**。如果线程T对数据A加上排他锁后，**则其他线程不能再对A加任何类型的锁**。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和 JUC中Lock的实现类就是互斥锁。

#### 共享锁

也可叫读锁。

共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程**只能对A再加共享锁，不能加排它锁**。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

这两个锁的应用可以见mysql。





